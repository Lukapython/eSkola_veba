<h1>Interfejsi Iterable, Iterator i ListIterator  </h1>
Sve klase kolekcija realizuju interfejs <b>Iterable</b>. To znači da se elementi svake kolekcije mogu pozvati <b>for –each</b> verzijom <b>for</b> petlje. Opšti oblik <b>for-each</b> verzije <b>for</b > petlje prikazan je u primeru 5.</br> 
<br><b>Primer 5:</b> For-each verzija for petlje</br>
<xmp class = "primer_ta"> 
for(Tip nazivPromenljive: naziv_kolekcije){
// rad sa elementima
 } </xmp>
Ovo je kraći i jednostavniji način za prolazak kroz kolekciju. Međutim, <b>for – each </b>verzijom <b>for</b> petlje nije moguće menjati ili izlistati elemente u obrnutom poretku. U tom slučaju koristi se <b>iterator</b>. Iterator je objekat koji realizuje interfejs <b>Iterator</b> ili <b>ListIterator</b>. Interfejs <b>Iterator</b> omogućava prolazak kroz kolekciju i omogućava učitavanje ili uklanjanje elemenata iz nje. Sa druge strane, interfejs <b>ListIterator</b> proširuje interfejs <b>Iterator</b> i omogućava prolaz kroz listu u oba smera, kao i menjanje njenih elemenata.</br>
<br><b>Iterator</b> i <b>ListIterator</b> su generički interfejsi koji se deklarišu na sledeći način:</br>
<xmp class = "primer_ta">  
Interface Iterator <E>
Interface ListIterator <E> </xmp>
gde <b>E</b> označava tip objekata kojima se pristupa. 
<br>Metode koje deklariše interfejs <b>Iterator</b> prikazane su u tabeli 2.</br>
<br><b>Tabela 2.</b> Metode interfejsa Iterator<br>
<table class = "tabela">
<thead>
<tr>
<th>Metoda</th> 
<th>Opis</th>
</tr>
<tr>
<tbody>
</tr>
<tr>
<td width="263">
<p>boolean hasNext()</p>
</td>
<td width="295">
<p>Vraća <b>true</b> ako ima jo&scaron; elemenata u kolekciji.&nbsp; U suprotnom vraća <b>false</b><em>.</em></p>
</td>
</tr>
<tr>
<td width="263">
<p>E next()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
</td>
<td width="295">
<p>Vraća sledeći element. Ako takvog elementa nema, generi&scaron;e izuzetak <b>NoSuchElementExeption</b><em>.</em></p>
</td>
</tr>
<tr>
<td width="263">
<p>void remove()</p>
</td>
<td width="295">
<p>Bri&scaron;e tekući element. Pri poku&scaron;aju da se pozove metoda <b>remove()</em></b> kojoj ne prethodi poziv metode <b>next(),</b> generi&scaron;e se izuzetak <b>IllegalStateExeption()</b>.</p>
</td>
</tr>

</tbody>
</table>
<br>Metode koje deklariše interfejs <b>ListIterator</b> prikazane su u tabeli 3.</br>
<br><b>Tabela 3.</b> Metode interfejsa ListIterator</br>
<table class = "tabela">
<thead>
<tr>
<th>Metoda</th> 
<th>Opis</th>
</tr>
<tr>
<tbody>
	<tr>
<td width="266">
<p>void add(E objekat)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
</td>
<td width="292">
<p>Umeće objekat na trenutnu poziciju u listi (ispred elemetna koji će biti vraćen sledećim pozivom metode <b>next())</b></p>
</td>
</tr>
<tr>
<td width="266">
<p>boolean hasNext()</p>
</td>
<td width="292">
<p>Vraća <b> true </b> ako ima jo&scaron; elemenata u kolekciji.&nbsp; U suprotnom vraća <b>false</b>.</p>
</td>
</tr>
<tr>
<td width="266">
<p>boolean hasPrevious()</p>
</td>
<td width="292">
<p>Vraća <b>true </b> ako postoji prethodni elemenata u kolekciji.&nbsp; U suprotnom vraća vrednost<b> false</b>.</p>
</td>
</tr>
<tr>
<td width="266">
<p>E next()</p>
</td>
<td width="292">
<p>Vraća sledeći element. Ako takvog elementa nema, generi&scaron;e izuzetak <b>NoSuchElementExeption </b>.</p>
</td>
</tr>
<tr>
<td width="266">
<p>int nextIndex()</p>
</td>
<td width="292">
<p>Vraća indeks sledećeg elementa. Ako takvog elementa nema, vraća veličinu liste.</p>
</td>
</tr>
<tr>
<td width="266">
<p>E previous()</p>
</td>
<td width="292">
<p>Vraća prethodni element. Ako takvog elementa nema generi&scaron;e izuzetak <b>NoSuchElementExeption </b>.</p>
</td>
</tr>
<tr>
<td width="266">
<p>int previousIndex()</p>
</td>
<td width="292">
<p>Vraća indeks prethodnog elementa. Ako takvog elementa nema, vraća -1.</p>
</td>
</tr>
<tr>
<td width="266">
<p>void remove()</p>
</td>
<td width="292">
<p>Bri&scaron;e tekući element. Pri poku&scaron;aju da se pozove metoda <b>remove</b><em>()</em> kojoj ne predhodi poziv metode <b>next()</b> generi&scaron;e se izuzetak <b> IllegalStateExeption()</b></p>
</td>
</tr>
<tr>
<td width="266">
<p>void set(E objekat)</p>
</td>
<td width="292">
<p>Dodeljuje objekat tekućem elementu, tj. onom koji je poslednji vraćen pomoću metoda <b>next()</b> i <b>previous().</b></p>
</td>
</tr>
</tbody>
</table>
<br>Može se posmatrati kao da su Java iteratori na pozicijama između elemenata. Pri pozivu metoda <b>next()</b>, iterator preskače preko sledećeg elementa, i vrace referencu na element preko kog je upravo prešao.</br> 
<br>Ukoliko je potrebno posetiti sve elemente kolekcije, neophodno je:</br>
<ul style="list-style-type:circle">
<li>Kreirati iterator koji pokazuje na početak kolekcije koristeći metod <b>iterator()</b> (metoda <b>Collection</b> interfejsa)  </li>
<li> Uspostaviti petlju koja treba da se vrti sve dok metoda <b>hasNext()</b> vraća vrednost <b>true</b> </li>
<li>Pozovati metodu <b>next()</b> unutar petlje da bi se dobila referenca na sledeći element kolekcije </li>
</ul>
<br><b>Primer 6:</b> Posećivanje svih elemenata kolekcije pomoću iteratora   </br>
<xmp class = "primer_ta"> 
Collection<Tip> c = …; // definisanje kolekcije c
Iterator iter = c.iterator(); // kreiranje iteratora 
while(iter.hasNext()){ 
Tip element = iter.next(); // referenca na naredni element
// Radi se nešto sa elementom
} </xmp>
 Brisanje elemenata ostvaruje se korišćenjem metode <b>remove()</b>. Metod <b>remove()</b> interfejsa <b>Iterator</b> uklanja element vraćen poslednjim pozivom metoda <b>next()</b>. Primer 7. ilustruje uptrebu metode <b>remove()</b>.</br> 
<br><b>Primer 7:</b> Brisanje elementa upotrebom iteratora</br> 
<xmp class = "primer_ta"> 
Iterator it = c.iterator();// kreiranje iteratora
it.next(); // preskakanje prvog elementa
it.remove(); // brisanje elementa </xmp>
Postoji veza izmedu poziva metoda <b>next()</b> i <b>remove()</b>. Nije ispravno pozvati metod <b>remove()</b> ako nije prethodio poziv metoda <b>next().</b> Ukoliko se metoda <b>remove()</b> pozove dva puta, generisaće se izuzetak - <b>IllegalStateException.</b>  Dakle, ukoliko je potrebno izbrisati dva susedna elementa, nije ispravno  pozvati:
<xmp class = "primer_ta"> 
it.remove();
it.remove(); // Greška! </xmp>
Umesto toga, prvo se poziva metod <b>next()</b> kako bi iterator prešao preko elementa koji treba ukloniti, pa tek onda se poziva metod <b>remove().</b> Dakle, potrebno je uraditi sledeće:
<xmp class = "primer_ta"> 
it.remove();
it.next();
it.remove(); </xmp>
Iterator za kolekcije koje implementiraju interfejs <b>List</b> može se dobiti i pozivanjem metode <b>listIterator().</b> Kao što je već naglašeno ovaj iterator omogućava da se elementima liste pristupa u oba smera. Dakle, kao što je prikazano u tabeli 3, za razliku od interfejsa <b>Iterator</b>, interfejs <b>ListIterator</b> poseduje metodu <b>add()</b> koja dodaje element ispred tekuće pozicije iteratora. <b>ListIterator</b> poseduje i dva metoda koji mogu da se koriste za obilaženje liste unazad - <b>previus()</b> i <b>hasPrevious().</b> Takođe, interfejs <b>ListIterator</b> poseduje metod koji vraća indeks tekuće pozicije. Zapravo, kako iteratori konceptualno pokazuju između elemenata, postoje dva takva metoda -   <b>nextIndex()</b> koji vraća celobrojni indeks elementa koji ce biti vraćen narednim pozivom metoda <b>next()</b>, i <b>previousIndex()</b> koji vraća indeks elementa koji će biti vraćen narednim pozivom metoda <b>previous().</b> Na kraju, metod <b>set()</b> zamenjuje poslednji element vraćen pozivom metoda <b>next()</b> ili <b>previous() </b>novim elementom.</br>