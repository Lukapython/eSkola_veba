<h1>PROMENLJIVE</h1>
<br>
Promenljiva po definiciji ne predstavlja ništa drugo nego deo prostora u memoriji kojem je dato neko ime i na kome se čuvaju podaci koji se nazivaju vrednosti. Ako je planeta Zemlja jedna velika memorija onda bi deo memorije bila neka lokacija
na Zemlji koja se može potpuno odrediti pomoću geografske širine i dužine. Tako bi kordinate 35° 41′ 0″ N, 139° 41′ 0″ E predstavljale " deo memorije " koja je još poznata pod imenom Tokio. Naravno i promenljive su uvedene iz praktičnih razloga kao što
što je i Tokio a ne 35° 41′ 0″ N, 139° 41′ 0″.  Pravila za davanje imena promenljivoj ostala su ista kao
u JavaScript-u, pa da se podsetimo nekih od njih. Neformalno se može reći da promenljive služe za čuvanje vrednosti. <!-- Ovde samo navodimo pravila vezano za ime promenljiive a ne i ostala pravila koja promenljiva mora da ispoštuje-->
<br>
<br>
<ul>
	<li>Imena promenljivih mogu sadržati slova i brojeve.</li>
	<li>Ne smeju sadržati specijalne simbole osim _ ili $.</li>
	<li>Ime promenljive ne može početi brojem.</li>
	<li>Ime promenljive ne može biti ključna reč.</li>
</ul>
<br>
Svaku promenljivu treba prvo deklarisati. Da bi deklarisali promenljivu potrebno je uraditi sledeće:
<br>
<br><!-- Ovo nije loše ilustoravti nekim sličicama ako ti ostane vremena da implementiraš-->

<textarea class = "primer_ta" rows = "4" disabled>

 let ImePromenljive;

</textarea>
<br>
Da bi deklarisali i naznačili da se radi o promenljivoj u kodu se koristi ključna reč <b>let</b> ili <b>var</b>. Promenljiva se može deklarisati i pomoću ključne reči <b>const</b> o čemu će posebno biti reči.
<br>
<br>
Ovo je dovoljno da bi deklarisali promenljivu. Primetimo da u odnosu na kod iz prethodnih lekcija
deluje kao da nešto "nedostaje"? Ono što "nedostaje" je deklaracija tipa
promenljive i vrednosti koju čuva. Međutim, čak i ovako deklarisana promenljiva ima svoj tip i vrednost.
U situacijama  kad to nije eksplicitno  urađeno tip promenljive se automatksi postavlja na <b>any</b> a vrednost na <b>undefined</b>.
<br>
<textarea class = "primer_ta" rows = "6" disabled>

//let ImePromenljive: tipPodatka;

  let ImePromenljive: number;

</textarea>
<br>
Za deklaraciju tipa promenljive koriste se dve tačke (<b>:</b>)  posle kojih se navodi kog tipa  želimo da naša promenljiva bude tj. koji tip vrednosti očekujemo da će da čuva. Opet je izostavljena vrednost 
pa će ona biti automatski postavjlena na undefined.
<br>
<textarea class = "primer_ta" rows = "6" disabled>

//let ImePromenljive: tipPodatka = vrednost;

  let ImePromenljive:   number   = 4;

</textarea>
<br><!-- Da li pisati reči za simbole ili odmah npr napisati = umesto jednako ?-->
Korišćenjem operatora jednako (<b>=</b>) promenljivoj dodeljujemo vrednost. U gore navedenom primeru promenljivoj ImePromenljive koja je deklarisana tako da je tipa number dodeljujemo vrednost 4 koja je takođe tipa number.
Za ovakav vid deklaracije može se reći da je potpun jer je deklarisan i tip promenljive i dodeljena joj je vrednost pa se može bez problema koristiti u drugim delovima koda.
<br>
<br>
Može se još dogoditi da promenljivoj dodelimo vrednost a ne deklarišemo tip , tada će njen tip automatski biti postavljen  na osnovu tipa njene vrednosti. Primetimo još da se u kodu uvek koristi <b>let</b> iako ipostoji izbor da se koristi i <b>var</b>. Razlog
iza ovakve odluke leži u tome da korišćenjem ključne reči <b>let</b> u kodu manja je šansa pravljenja ne toliko sintaksnih koliko semantičkih grešaka. Kasnije u lekciji će biti izneta poređenja i razlozi koji stoje iza ove odluke.
Naravno izbor između <b>let</b> i <b>var</b> leži na pojedincu.
<br>
<div class = "napomena">
Jedna od stvari koje u ovom trenutku treba skrenuti pažnju čitaocu je i podudaranje tipova. Podudaranje tipova podrazumeva jednostavno pravilo koje očekuje da se tip promenljive i tip vrednosti podudaraju.
Neformalnim jezikom govoreći očekuje se da tipovi sa obe strane jednakosti budu isti inače će u procesu kompilacije doći do greške.
</div>
<br>
<b>Domen promenljive u okviru koda</b> <!-- Ili Pravila domena dostupnosti  promenljive u okviru koda ?-->
<br>
Domen promenljive predstavlja deo koda u kojem je promenljiva definisana. Dostupnost promenljive unutar programa zavisi od njenog domena. U prevodu van domena promenljiva kao da ne postoji i ne može se koristiti iako je deklarisana i 
nalazi se u memoriji. U TypeScript-u promenljive mogu da imaju jedan od sledećih domena:
<br>
<br>
<ul>
	<li><b>Globalni domen</b>- Globalne promenljive su promenljive koje su deklarisane izvan programskih konstrukta<!-- Možda bi bilo lepo objasniti šta su programski konstrukti :) ?-->. Ovim promenljivima se može pristupiti iz bilo kog dela koda.</li>
	<li><b>Domen klase</b>- Ove promenljive se još zovu polja ili atributi. Polja tj. promenljive klasa su deklarisane unutar klasa ali izvan metoda. Ovim promenljivim se može pristupiti putem objekta klase u kome se nalaze. Polja mogu da budu i statična
	i u tom slučaju im se pristupa preko imena klase.</li>  <!-- Ako atribut u klasi se tretiraju kao promenljive zašto ne možemo da koristimo let nego to izostavljamo da bi ga prepoznalo kao atribut ?-->
	<li><b>Lokalni domen</b>- Lokalne promenljive kao što im ime sugeriše su promenljive koje su deklarisane unutar konstrukcija kao što su metodi, petlje, blokovi naredbi itd. Lokalnim promenljivima se može pristupiti samo unutar konstrukcija u kojima se nalaze.</li>
	
</ul>
<br>
Nakon sledećeg primera će postati jasnije.
<br>
<textarea class = "primer_ta" rows = "43" disabled>

  let GlobalnaPromenljiva: number = 100;
  
  function FUNKCIJA() : number {
  
  let LokalnaPromenljiva: number = 1;
  
  return (GlobalnaPromenljiva + LokalnaPromenljiva) ;
  }

  class KLASA {

   static PromenljivaKlase: number = 1;
   PromenljivaKlase2: number = 5;
    
  
  }
  
  let Objekat = new KLASA();
  
  let Zbir : number = FUNKCIJA() + Objekat.PromenljivaKlase2;
  
  // 1. Ako izbrišemo deo koda (let Objekat = new KLASA();) i Objekat.PromenljivaKlase2 zamenimo sa PromenljivaKlase2
  
  let Zbir1: number = GlobalnaPromenljiva + KLASA.PromenljivaKlase;
  
  // 2. Umesto KLASE.PromenljivaKlase saberite sa LokalnaPromenljiva
  
  
  let button1 = document.createElement('button');
  let button2 = document.createElement('button');
 button1.textContent = "Dugme1";
 button1.onclick = function () {
     alert(Zbir);
 };
 button2.textContent = "Dugme2";
 button2.onclick = function () {
     alert(Zbir1);
 };
 document.body.appendChild(button1);
 document.body.appendChild(button2);
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
Ako ste pokušali da izmenite deo koda kao što piše u komentaru 1. ili 2. primetićete da kompilacija nije prošla. Pojaviće se obaveštenje <b>Cannot find name 'PromenljivaKlase2'.</b>  ili <b>Cannot find name 'LokalnaPromenljiva'.</b> u zavisnosti od toga šta ste  od navedenog uradili iz komentara.
Greške su se javile baš zbog pokušaja upotrebe promenljive van njihovog domena definisanosti. Dakle, promenljivoj GlobalnaPromenljiva se može pristupiti u bilo kom delu koda dok promenljivoj LokalnaPromenljiva samo unutar funkcije u kojoj je i deklarisana. Pokušaj pristupa toj promenljivoj van funkcije
proizvelo bi grešku jer je kompajler uopšte ne prepoznaje da postoji van funkcije ( Ponaša se prema njoj kao što bi se ponašao prema nekoj drugoj promenljivoj u kodu koja uopšte nije deklarisana). Što se tiče promenljivih klasa, njima se može pristupiti sve dok im se pristupa preko objekata u kojima se nalaze jer im je to i domen.
Kad bi pokušali da im pristupimo samo preko njihovog imena kompajler ih ne bi prepoznao. 
<br>
<br>
<b>SUGESTIJA TIPA</b><!-- Možda nagoveštavanje tipa ?-->
<br>
<br>
TypeScript dopušta da kompajleru naglasimo da želimo da naša promenljiva  tipa P  bude tumačena kao promenljiva tipa D. Ovaj proces se još na engleskom zove Type Assertion. Sintaksa je sledeća, tip u koji želimo da promenimo se postavlj između <> a sve to isped promenljive ili nekog izraza. Ovo je izvodljivo
samo ako je tip P podtip tipa D ili tip D podtip tipa P. Type Assertion ne treba mešati sa Type Casting jer Type Casting uključuje i podršku pri izvršavanju programa dok je Type Assertion čisto proces koji se dešava u procesu kompilacije. Prostim jezikom govoreći  Type Assertion
predstavlja način  da se kompajleru skren pažnja kako želimo da naš kod bude protumačen.
<br>
<br>
<textarea class = "primer_ta" rows = "19" disabled> 

  let str1: number = 1; 
  let str2: string  = <string> <any> str1   

  //Ovde number nije podtip stringa niti obratno tako da prvo menjamo tip na any pa onda sa any na string.
  // Any je nadtip number i string tjst oni su podtipovi any. 
  //Ovde smo imali dve promene tipa i to je bilo neophodno uraditi kako bi bio zadovoljen gore navedeni uslov.
  //Inače bi dobili grešku Type 'number' cannot be converted to type 'string'.


let button = document.createElement('button');
 button.textContent = " Dugme ";
 button.onclick = function () {
    alert(str2);
 };
 document.body.appendChild(button);

</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
<br>
<b>DODELJIVANJE TIPA NA OSNOVU VREDNOSTI</b>
<br>
Iako je TypeScript jako tipiziran, ovaj pristup je stvar izbora. TypeScript pruža mogućnost i dinamičkog dodeljivanja tipa promenljivoj. Dinamičko dodeljivanje tipa promenljivoj podrazumeva da se odluka o tome kog će tipa biti promenljiva
prepušta TypeScript-u. Ako nije eksplicitno naveden  tip promenljive onda će u procesu kompilacije kompajler sam dodeliti tip promenljivoj na osnovu tipa vrednosti koja joj je dodeljena promenljivoj. Primer kako to funkcioniše možete videti u nastavku lekcije.
<br>
<br>
<textarea class = "primer_ta" rows = "13" disabled> 

   let x= 1; 
   
   //x="1";
   
   let button = document.createElement('button');
   button.textContent = " Dugme ";
   button.onclick = function () {
      alert("I promenjiva je tipa " + typeof x + ".");
   };
   document.body.appendChild(button);

</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
Korišćenjem unarnog operatora <b>typeof</b> proverava se tip promenljive i dobijeno je da je number. Ako bi dodali i kod koji stoji pod komentarima dobili bi grešku <b>Type '"1"' is not assignable to type 'number'.</b>.Pošto je već kompajler dodelio
promenljivoj x tip number, dodeljivanjem stringa promenljivoj x nema smisla jer se tip promenljive i tip nove vrednosti razlikuju. Ovo je bio jedan od načina da se pokaže da TypeScript dinamički dodeljuje tip promenljivoj u situaciji kad nije eksplicitno deklarisan.
<br>
<br>
<b>KONSTANTE</b>
<br>
Još jedan od načina da se deklariše promenljiva je da se upotrebi ključna reč <b>const</b>. Upotrebom ključne reči <b>const</b> u kodu, naznačava se kompajleru da vrednost promenljive ostaje nepromenjena tokom čitavog izvršavanja programa.
Const je skraćenica od constant što u prevodu znači znači stalan, nepromenliv. Pokušaj dodeljivanja nove vrednosti promenljivoj (označimo je sa x) koja je deklarisana kao const rezultiraće greškom <b>Cannot assign to 'x' because it is a constant or a read-only property.</b> .
<br>
<textarea class = "primer_ta" rows = "22" disabled> 
  const Broj:number =5;
  
  const Reč :string ="Tekst";
  
  const Grad = {
    ime: "Kyoto",
    brojStanovnika: 1,475,183;
	readonly Himna:"Kimi gayo"
};

  //Kad smo kod objekata sledeće nije dozvoljeno:

  /*  
   const Grad = {
       ime: "Beograd",
       brojStanovnika: 1,233,796;
	   readonly Himna:"Bozepravde"
   };
    Ono što je jeste...
  */ 

  Grad.ime = "Hirošima";
  Grad.brojStanovnika = 1,196,274;
</textarea>
<br>
Kada se pomene reč const obično se misli na matematičke konstante ali za svaku promenljivu koju deklarišemo kao const  njena vrednost postaje nepromenljiva tj. konstantna. Iz gore navedenog primera vidi se da promenljiva tipa string može da bude
konstantna tj. vrednost promenljive Reč ne može da bude nijedan drugi string sem stringa "Tekst". Kada su u pitanju objekti mora da se vodi računa jer "vrednost" promenljive predstavlja sve pod vitičastim zagradama tj. predstavlja sam objekat. Tako da, iako nije
moguće menjati jedan objekat sa drugim kao što je prikazano u primeru moguće je menjati vrednosti polja koja se nalaze u samom objektu. Vrednost nije moguće menjati ako je polje označeno modifikatorom <b>readonly</b>.
<br>
<br>
<b>RAZLIKA IZMEĐU LET I VAR</b>
<br>
<br>
U ovom odeljku će biti navedeno par najbitnih razlika između let i var. Najveća zamerka i razlog zbog kog su autori TypeScript odlučili da se opredele za let a ne var leži u činjenici da promenljiva deklarisana sa var ima različit domen 
definisanosti od domena koji bi imala kad bi bila deklarisalna pomoću let. Zbog ove činjenice ostavlja se veći prostor za pravljenje semantičkih grešaka nego što bi to bio slučaj da smo promenljivu deklarisali pomoću let. Pogledajmo:
<br>
<br>
<textarea class = "primer_ta" rows = "23" disabled>  
  function testFunkcija ( x: number ) {
  
         if (x == 1){
		 
		  var y =2; //let y = 2;
		  
		 }
  
      return y;// Cannot find name 'y'.

     }
	 
	 
   var h =testFunkcija(1);
   var j =testFunkcija(2);
   var button = document.createElement('button');
   button.textContent = "Pa da pogledamo.";
   button.onclick = function () {
    alert("Vrednost h je " + h + " a" + " j je " + j + "." );
    };
   document.body.appendChild(button);
   
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
Možemo primetiti da se promenljiva y deklarisana pomoću <b>var</b> ponaša kao globalna promenljiva a ako je deklarisana pomoću <b>let</b> onda se ponaša kao lokalna. U prilog tome govori gore navedeni primer. Pri pozivu funkcije testFunkcija za vrednost x-a dva,
uslov unutar funkcije neće biti zadovoljen pa pri tome neće biti ni instrukcije da se deklariše promenljiva y. Uprkos tome može se pristupiti promenljivoj y koja ima vrednost undefined. Ako se umesto var upotrebi let onda će se dobiti greška 
<b>Cannot find name 'y'.</b> zbog pokušaja  da pristupimo y izvan bloka u kome je definisana. Pogledajmo još neki primer:
<br>
<div class = "napomena">
Za čitaoce koji pokušaju da izmene kod i umesto var stave let, treba skrenuti pažnju da program ne bi trebalo da se pokrene. Kao što je zaključeno program ima grešku. Ako se program ipak pokrene to je zato što je TS kompajler iskaz <b>let y =2;</b>
zamenio iskazom <b>var y =2;</b>. U tom slučaju u dobijenom JavaScript kodu treba samo <b>var y =2;</b> zameniti sa <b>let y =2;</b>.
</div>
<br>
Jedan od problema koji se sreće kada se promenljive deklarišu pomoću var jeste da je moguće jednu promenljivu deklarisati više puta.
<textarea class = "primer_ta" rows = "20" disabled>  
  let M: number [][] = [[1, 2, 3, 4],[4, 3, 2, 1],[5, 6, 7, 8], [9, 10, 11, 12]];
  
  var S = 0;
    for (var i = 0; i < M.length; i++) {
        var trenutniRed = M[i];
        for (var i = 0; i < ctrenutniRed.length; i++) {
            S =S + trenutniRed[i];
        }
    }
     
	// Ovako nećemo daleko dogurati jer samo prođe kroz prvi red. 
	 
   var button = document.createElement('button');
   button.textContent = "Pa da pogledamo.";
   button.onclick = function () {
    alert(S);
    };
   document.body.appendChild(button);
   
</textarea>
<button class = "button_copy">Vidi primer</button>
<textarea class = "primer_ta" rows = "20" disabled>  
  let M: number [][] = [[1, 2, 3, 4],[4, 3, 2, 1],[5, 6, 7, 8], [9, 10, 11, 12]];
  
  var S = 0;
    for (let i = 0; i < M.length; i++) {
        var trenutniRed = M[i];
        for (let i = 0; i < trenutniRed.length; i++) {
            S=S + trenutniRed[i];
        }
    }
     
	// Sad će proći kroz celu matricu 
	 
   var button = document.createElement('button');
   button.textContent = "Pa da pogledamo.";
   button.onclick = function () {
    alert(S);
    };
   document.body.appendChild(button);
   
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
Kao što je već pomenuto svaka promenljiva koja je deklarisana pomoću var jeste globalna. Zbog toga po završetku "unutrašnje" for petlje, <b>i</b> koje je deklarisano u petlji će i dalje nastaviti da postoji. 
Ulazak po drugi put u "spoljasnju" for petlju nije moguće jer nije zadovoljen uslov <b>i < M.length</b>. U slučaju kada su promenljive deklarisane sa let svaka od deklarisanih <b>i-ova</b> ima lokalni domen u okviru svoje for petlje tako da nema kolizije ili zabune.
Ovo je bio kratak pregled elementarnih stvari vezanih za promenljive. Na kraju lekcije postoje zadaci kako bi se moglo proveriti dosad savladano.
<br>
<br>
<div class = "zadatak">
<b>Zadatak3:</b><br>
 a)Deklarisati 3 promenljive tako da jedna ima globalni, druga klasni a treća lokalni domen. Na primeru testirati njihove domene.<br>
 b)Deklarisati promenljivu tipa string tako da ima vrednost "5" bez upotrebe ( s: string = "5" ili st: number = s;).<br>
 c)Deklarisati promenljivu tipa string tako da ima vrednost "true"  bez upotrebe ( s: string = "true" ili st: string = s;).<br>
</div>