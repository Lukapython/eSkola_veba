<h1>Kontrola toka programa i rukovanje izuzecima</h1><!-- Da li je iskaz isto što i naredba ?-->
<br> 
Kontrola toka predstavlja redosled kojim se pojedinačni iskazi, instrukcije ili pozivi funkcija proveravaju ili izvršavaju. Na osnovu eksplicitne kontrole toka pravi se razlika između imperativnih i deklarativnih programskih jezika.
TypeScript podržava kompaktan skup iskaza, konkretno skup iskaza zaduženih za kontrolu toka programa. Jedna od prvih stvari sa kojom se susrećemo je tačka-zarez(;). Tačk-zarez se koristi kako bi razdvojili iskaze u TypeScript-u.
<br>
<br> 
<b>BLOK ISKAZ</b> 
<br>
<br>
Jedan od najosnovnih iskaza je blok iskaz koji se upotrebljava kako bi grupisali druge iskaze. Da bi se nešto smatralo blok iskazom dovoljno je da se upotrebe vitičaste zagrade između kojih se navode iskazi koji se grupišu. Blok iskazi se uglavnom koriste u kombinaciji sa iskazima za kontrolu toka.
<br>
<textarea class = "primer_ta" rows = "10" disabled> 
{
  iskaz_1;
  iskaz_2;
  .
  .
  .
  iskaz_n;
}

</textarea>
<br>
U kombinaciji sa nekim iskazom kontrole toka to bi izgledalo ovako:
<br>
<textarea class = "primer_ta" rows = "9" disabled> 
  if ( x != 10)
     {
	 
	 let y: number = x + 10;
	 
         x++;
	 
     }
</textarea>
<br>
U iskaze za kontrolu toka upravo spadaju i uslovni iskazi.
<br>
<br>
<b>USLOVNI ISKAZI</b> 
<br>
<br>
Uslovni iskaz predstavlja niz instrukcija koje se izvršavaju ako je zadovoljen specifičan uslov tj. ako je povratna vrednost izraza <b>true</b>. TypeScript podržava dve vrste uslovnih iskaza <b>if ... else</b> i <b>switch</b>.
<br>
<br>
IF ... ELSE ISKAZ
<br>
<br>
Iskaz <b>if</b> se koristi da bi izvršili iskaz ili blok iskaza u slučaju kada je povratna vrednost uslova true. Iskaz <b>else</b> opciono se može da upotrebi da bi izvršili iskaz ili blok iskaza u slučaju kada je povratna vrednost uslova false. <b>Uslov</b> je izraz koji može imati vrednost true ili false.
<br>
<textarea class = "primer_ta" rows = "16" disabled>

     if (uslov) {
	 
        izraz_1;
        izraz_2;
                } else {		
        izraz_3;
                }
				
	//Iskaz else je opcioni , može i bez njega
	
	if (uslov) {
             izraz_1;
		
		izraz_2;
                }
</textarea>
<textarea class = "primer_ta" rows = "15" disabled>

 let x: number = 6;
 let y: number = 5;
 
 if (x > y){
      let button = document.createElement('button');
      button.textContent = "Rezultat";
      button.onclick = function () {
      alert(" Pošto je uslov zadovoljen tjst 6 je veće od 5 izvršiće se ovaj blok iskaza. Zameniti u kodu x > y sa x < y pa da vidimo šta će se desiti? :)");
           };
      document.body.appendChild(button);
 
           }
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
Else se takođe može upotrebiti kako bi konstruisiali više uslova koji bi se proveravali redom.
<br>
<textarea class = "primer_ta" rows = "18" disabled>

     if (uslov_1) {
	 
           iskaz_1;
		   
        } else if (uslov_2) {
		
           iskaz_2;
		   
        } else if (uslov_3) {
		
           iksaz_3;
		   
        } else {
		
           poslednji_iskaz;
        } 	
</textarea>
Kako to izgleda na primeru:
<br>
<textarea class = "primer_ta" rows = "31" disabled>

     let x: number = 6;
     let y: number = 5;
 
         if (x == y) {
	 
           button.onclick = function () {
           alert(" x i y su jednaki");
           };
         
        } else if ( x > y) {
		
           button.onclick = function () {
           alert(" x je vece od y ");
           };
		   
        } else if ( x < y ) {
		
           button.onclick = function () {
           alert(" x je manje od y ");
           };
		   
        } else {
		
           button.onclick = function () {
           alert(" x i y nisu uporedivi ");
           };
        } 	
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
U ovoj situaciji treba napomenuti da se uslovi proveravaju do prvog zadovoljenog a da se ostali uslovi ne proveravaju.
<br>
<br>
SWITCH ISKAZ
<br>
<br>
Switch iskaz omogućava programu da odredi vrednost <b>početnog izraza</b> i da tu vrednost uporedi sa vrednostima u <b>slučajevima</b> koji su definisani u switch bloku. Ako se vrednosti poklapaju onda se izvršava niz iskaza koji su definisani za taj slučaj.
Da bi definisali slučaj koristi se ključna reč <b>case</b> i : između kojih stoji izraz. Posle : ide skup iskaza koji treba da se izvrši. Nakon poslednjeg iskaza u slučaju koristi se ključna reč <b>break</b> da bi izašli iz switch bloka i sprečili mogućnost da se izvrše iskazi iz jos nekog slučaja.
Ako se vrednost početnog izraza ne poklapa sa vrednosti nijednog slučaja onda se može upotrebiti ključna reč <b>default</b> kako bi naznačili da će se tom slučaju izvršiti sledeći niz naredbi. Treba skrenuti pažnju da je upotreba ključnih reči <b>break</b> i <b>default</b> opciona. 
<br>
<textarea class = "primer_ta" rows = "24" disabled>

     switch (početni_izraz) {
          case slučaj_1:
		  
            iskaz_1;
			iskaz_2;
			
           break;
          case slučaj_2:
		  
            iskaz_3
			iskaz_4;
			iskaz_5;
			
           break;
		  default:
		  
            iskaz_koji_se_izvršava_kad_nijedan_od_slučajeva_nije_zadovoljen;
			iskaz_koji_se_izvršava_kad_nijedan_od_slučajeva_nije_zadovoljen_1;
			
           break;
}
</textarea>
<br>
Kako to izgleda na primeru.
<br>
<textarea class = "primer_ta" rows = "30" disabled>

    let s1: string = "Užice";
    let s2: string = "Beograd";
    let button = document.createElement('button');
    button.textContent = "Rezultat";
    document.body.appendChild(button);

     switch ( s1 > s2 ) {
          case true:
		  
            button.onclick = function () {
            alert(" Heheh pozdrav iz Užica. ;)");
            };
			
           break;
          case false:
		  
            button.onclick = function () {
            alert(" Ima jedan grad zove se Beograd.");
            };
			
           break;
		  default:
		  
            button.onclick = function () {
            alert(" Ipak je najbolji Tokyo.");
            };
			
           break;
          }
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
<br>
<b>ISKAZI ZA RUKOVANJE IZUZECIMA</b> 
<br>
<br>
Tokom izvršavanja programa može doći do ne predviđenih situacija, abnormalnog ponašanja programa ili stanja u njemu. Posebna softverska podrška je zadužena za generisanje <b>objekta</b> koji sadrže informacije o uzroku nepredviđenog ponašanja programa. Ovi objekti se nazivaju <b>izuzeci</b>. Treba skrenuti pažnju da izuzeci mogu biti kreirani i od strane autora koda.
U TypeScript-u postoji više tipova izuzetaka. Postupak izbacivanja i hvatanja izuzetaka kao i pisanja koda koji je odgovor na taj izuzetak naziva se rukovanje izuzecima. Za izbacivanje i hvatanje izuzetka koriste se ključne reči <b>throw</b> i <b>catch</b>. Upravo pomoću ovih ključnih reči se formiraju izrazi za rukovanje izuzecima. 
Pre nego što nastavimo dalje sa lekcijom kratko ćemo se osvrnuti na tipove grešaka na koje možemo da naiđemo u TypeScript-u.( Napomena: kada govorimo o izuzecima pričamo o objektima koje kreiraju konstruktori klasa, u nastavku navodimo 7 klasa izuzetaka)
<br>
<br>
<ul>
<li><b>EvalError</b>-Kreira objekat koji predstavlja grešku koja nastaje u okviru globalne funkcije eval(). </li>
<br>
<!--  Izgleda ovaj tip greske nema u TypeScript? <li><b>InternalError</b>-Kreira objekat koji predstavlja grešku koja je se javlja kada se izbaci izuzetak kao posledica greške unutar programa koji pokreće JavaScript kod.?--> </li><!-- Svaki TypeScript kod se kompajlira da JavaScript izvršnog koda ?--> 
<br>
<li><b>RangeError</b>-Kreira objekat koji predstavlja grešku koja nastaje kada se brojevna promenljiva ili parametar nalaze van svog opsega definisanosti.</li>
<br>
<li><b>ReferenceError</b>-Kreira objekat koji predstavlja grešku koja se nastaje kada želimo da učitamo vrednost sa nevažećeg pokazivača.</li>
<br>
<li><b>SyntaxError</b>-Kreira objekat koji predstavlja sintaksnu grešku koja nastaje prilikom parsiranja koda u fukciji eval().</li>
<br>
<li><b>TypeError</b>-Kreira objekat koji predstavlja grešku koja nastaje kada promenljiva ili parametar nisu odgovarajućeg tipa.</li>
<br>
<li><b>URIError</b>-Kreira objekat koji predstavlja grešku koja nastaje kada se funkcijama encodeURI() ili decodeURI() prosleđeni nevažeći parametri.</li>
<ul/>
<br>
<br>
THROW ISKAZ
<br>
<br>
Iskaz throw se koristi kako bi izbacili izuzetak. Kada se izbacuje izuzetak u stvari se izbacuje vrednost izraza koji smo sami definisali. Treba napomenuti da se iskaz throw koristi da bi se izbacio izuzetak koji smo sami kreirali( Program za pokretanje JavaScript <!-- Svaki TypeScript kod se kompajlira da JavaScript izvršnog koda ?-->  koda ima sam po sebi ugrađen sistem za izbacivanje izuzetaka. ).
<br>
<br>
<span class = "primer_text"> throw izraz_čiju_vrednost_želimo_da_izbacimo ; </span>
<br>
<br>
U narednom primeru možete videti kako funkcioniše izbacivanje izuzetka.
<br>
<textarea class = "primer_ta" rows = "22" disabled>
    let y = "Užice";
    let x = 2;
	
    let button = document.createElement('button');
    button.textContent = "Rezultat";
    document.body.appendChild(button);
	
	if ( (typeof x) == "number" && (typeof y) == "number"){
           
	        button.onclick = function () {
            alert(x/y);
			};
			
          }else {
           
	       throw "Deljenik ili delilac nije broj!";
			
			};
				
// Postaviti vrednost y da bude broj i opet pokrenuti kod	
</textarea>
<button class = "button_copy">Vidi primer</button>
<div class = "napomena">
Treba biti oprezan pri korišćenju throw jer se njegovom upotrebom prekida dalji tok programa u <b>okviru bloka</b> u kome se nalazi. <br>
Izuzetak koji je izbačen se može videti u konzoli veb-pregledača. U našem slučaju dobićemo poruku <b>uncaught exception: Deljenik ili delilac nije broj!
</div>
</b>
</b>
Izuzeci se mogu kreirati i pomoću konstruktora gore navedenih klasa.
<br> 
<br> 
<span class = "primer_text">throw new ReferenceError(" Greška!"); </span>
<br>
<br> 
TRY...CATCH ISKAZ
<br>
<br>
Pomoću try...catch iskaza se pokriva blok iskaza u kome može doći do greške i definiše se odgovor na izuzetak koji može da se pojavi. Ako je izuzetak izbačen tj. ako se pojavi tu je try...catch iskaz da ga uhvati.
<br>
<br>
Try...catch iskaz se sastoji od <b>try</b> i <b>catch</b> bloka. U <b>try</b> bloku se nalazi skup iskaza u kojima može doći do greške dok u <b>catch</b> bloku, skup iskaza koji se izvršavaju kao odgovor na izbačeni izuzetak iz <b>try</b> bloka.
<b>Try</b> i <b>catch</b> bloka se formiraju pomoću ključnih reči <b>try</b> i <b>catch</b> iza kojih sledi blok iskaza. Kada dođe do greška i program prestane sa radom, try...catch iskaz pruža priliku da se adekvatno odreaguje na grešku koja je nastala u try bloku. Ovim pristupom se preusmerava tok programa i omogućava da se izvršavanje programa privede kraju. 
Treba da se napomene da se preusmeravanje toka programa vrši samo u situacijama  kada nastane greška inače  program se izvršava standardno.
<br>
<br>
<textarea class = "primer_ta" rows = "11" disabled>
    	    try{  
                  
				  iskaz_1;
			      iskaz_2;	  
		                                // Posle try bloka uvek ide catch blok!
                } catch ( izuzetak_koji_hvatamo ) {
			   
			      iskaz_3;
			      iskaz_4;
			   
			   }  
</textarea>
<textarea class = "primer_ta" rows = "52" disabled>
    	    let x:number;
			let y:number;
			
	let l1 = document.createElement('span');
    l1.textContent = "x: ";

    document.body.appendChild(l1);
  
    let input_1 = document.createElement('input'); 
    document.body.appendChild(input_1);

	
	
    let l2 = document.createElement('span');
    l2.textContent = "y: ";
    document.body.appendChild(l2);
    
    let input_2 = document.createElement('input');
    document.body.appendChild(input_2); 
    
	
	
	
	let button = document.createElement('button');
    button.textContent = "Rezultat";
    document.body.appendChild(button);
	
	button.onclick= f;
			
			function f() {
			
			x = parseInt(input_1.value.toString());
			
            y = parseInt(input_2.value.toString());
            
			try{  
                  if( y == 0){ 
				  
				  throw "Nije moguće deljenje 0, molim vas unesite drugi broj.";
				  
				  }
				 
				  alert(x/y);
				  
               } catch ( e ){  //(e kao exception)) 

			      alert(e);

			   }  
			  
			}
</textarea>
<button class = "button_copy">Vidi primer</button>
<div class = "napomena">
U TypeScript-u uvek posle try bloka ide <b>jedan</b> catch blok a ne više kao što je bio slučaj u nekim drugim programskim jezicima. Razlog leži u tome što autori TypeScript-a insistiraju da parametar catch bloka (e) bude tipa any.
Zbog toga se jednim catch blokom hvataju sve vrste izuzetaka. U nekim programskim jezicima postoji više catch blokova u zavisnosti od broja tipova izuzetaka koje "hvatamo". Kako  sa jednim catch blokom prepoznati i odgovoriti na određeni tip izuzetka? Dovoljno je upotrebiti operator <b>instanceof</b> u uslovu nekog uslovnog iskaza i definisati odgovor u zavisnosti od vrednosti uslovnog izraza. <br>( Operator instanceof se koristi nad objektima inače koristimo operator typeof)
U narednom primeru možete videti kako se kreira, hvata  i kreira odgovor na izuzetak.
</div>
<textarea class = "primer_ta" rows = "68" disabled>
    	    let x:number;
			let y:number;
			
	let l1 = document.createElement('span');
    l1.textContent = "x: ";

    document.body.appendChild(l1);
  
    let input_1 = document.createElement('input'); 
    document.body.appendChild(input_1);

    let l2 = document.createElement('span');
    l2.textContent = "y: ";
    document.body.appendChild(l2);
    
    let input_2 = document.createElement('input');
    document.body.appendChild(input_2); 
    
	let button = document.createElement('button');
    button.textContent = "Rezultat";
    document.body.appendChild(button);
	
	button.onclick= f;
			
			function f() {
			
			x = parseInt(input_1.value.toString());
			
            y = parseInt(input_2.value.toString());
            
			try{  
                  if( y == 0){ 
				  
				  throw "Nije moguće deljenje 0, molim vas unesite drugi broj.";
				  
				  }
				 
				 alert(x/y);
				  
                 let z:number = p; 
				  
				 // Izkaz let z:number = p; nema smisla jer p ne postoji! 
				  
				 // Unesite y != 0 i vidite koji će izuzetak prvi izbaciti.
				  
               } catch ( e ){  

			     if (e instanceof RangeError){ 

                    alert("Nije u opsegu.");
                }  
			   
                if (e instanceof ReferenceError){ 

                    alert(e);

                }  

                if (typeof e == "string"){ 

                    alert(e);

                }
            }  

			}
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
<br>
<!-- Može da se razvije diskusija o ugnježdenim try...catch iskazima ?-->
Treba imati u vidu da catch hvata prvi izuzetak koji izbacimo jer tu program prestaje sa radom. Postavlja se pitanje šta raditi ako se izbaci izuzetak a u catch bloku se ne reaguje na taj izuzetak, jednostavno nismo predvideli da može doći do tog tipa izuzetka pa nismo definisali ni odgovor. 
U tom slučaju greška će ostati netaknuta a program prestati sa radom. U ovim situacijama poželjno je imati neki blok iskaza, npr. kojim možemo da oslobodimo resurse računara koje je program koristio. Jedan od načina da se ovako nešto uradi je upotreba <b>finally</b> bloka.
Korišćenjem ključne reči <b>finally</b> iza koje sledi blok iskaza formira se finally blok. Ovaj blok se izvršava neposredno pošto se izvrše try i catch blokovi. Da ne bude zabune finally blok se izvršava bez obzira da li je izbačen izuzetak ili ne. Ako je izbačen izuzetak a cathc blok ne odreaguje na taj izuzetak finally blok će se opet izvršiti.
Naredni primer ilustruje upotrebu finally bloka.
<br>
<br>
<textarea class = "primer_ta" rows = "50" disabled>
    	    let x:number;
			let y:number;
			
	let l1 = document.createElement('span');
    l1.textContent = "x: ";

    document.body.appendChild(l1);
  
    let input_1 = document.createElement('input'); 
    document.body.appendChild(input_1);

    let l2 = document.createElement('span');
    l2.textContent = "y: ";
    document.body.appendChild(l2);
    
    let input_2 = document.createElement('input');
    document.body.appendChild(input_2); 
    
	let button = document.createElement('button');
    button.textContent = "Rezultat";
    document.body.appendChild(button);
	
	button.onclick= f;
			
			function f() {
			
			x = parseInt(input_1.value.toString());
			
            y = parseInt(input_2.value.toString());
           				  
                try{  
                  if( y == 0){ 
				  
				  throw "Nije moguće deljenje 0, molim vas unesite drugi broj.";
				  
				  }
				 
				  alert("Zbog 0 tjst throw treba da iskoči iz try bloka ako se ovo dešava onda znači da smo uneli y različito od nule.");
				  alert(x/y);
				  
               } finally {
				
                 alert("Kod u finally bloku se izvršava...");
                 alert(x/y);
				 window.close();
                        }
			}
</textarea>
<button class = "button_copy">Vidi primer</button>
<br>
<br>
Primetite da u prethodnom primeru nema catch blok, što je potpuno sintaksno ispravno jer on služi za hvatanje izuzetaka. Ako ne želimo da hvatamo izuzetke onda ne moramo da koristimo catch. Ono što je bitno napomenuti da finally blok mora da ide posle catch bloka tj. posle try bloka ako catch bloka nema.
Ako se catch i finally blok nalaze u funkciji a koristimo u oba bloka <b>return</b> onda će se prioritet dati return-u koji je upotrebljen u finally bloku.
<br>
<br>
<!-- Može da se razvije diskusija o Erro klasi i korišćenju objekata te klase, Promise klasa ?-->
<div class = "zadatak">
<b>Zadatak5:</b><br>
Napisati program tako da korisnik može da pristupi članovima niza i da vidi vrednost člana kome je pristupio. U slučaju da korisnik pokuša da pristupi članu koji ne postoji, izuzetak mora biti uhvaćen i ispisana poruka da taj član niza ne postoji.
</div>